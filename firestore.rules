
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Journal Entries: Users can only read/write their own entries.
    match /journalEntries/{entryId} {
      allow read, write: if request.auth != null && request.resource.data.userId == request.auth.uid;
    }

    // Posts: Any authenticated user can read/create/update posts.
    match /posts/{postId} {
      allow read, create: if request.auth != null;
      allow update: if request.auth != null; // Allows liking and comment count updates

      // Comments: Authenticated users can read/write comments on any post.
      match /comments/{commentId} {
        allow read, create: if request.auth != null;
        allow update: if request.auth != null; // For liking comments
      }

      // Likes on Posts
      match /likes/{userId} {
        allow read, create, delete: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // Friend Requests:
    match /friendRequests/{requestId} {
      // Allow read/create if logged in.
      allow read, create: if request.auth != null;
      // Allow update/delete only by the sender or receiver.
      allow update, delete: if request.auth != null && (resource.data.fromUserId == request.auth.uid || resource.data.toUserId == request.auth.uid);
    }

    // Friends lists:
    match /users/{userId}/friends/{friendId} {
        // Users can only manage their own friends list.
        allow read, write, delete: if request.auth != null && request.auth.uid == userId;
        // A user can also add a friend to another user's list, but ONLY if they are accepting a request.
        // This is a more advanced rule to secure the transaction.
        // For simplicity, we'll keep the current rule which works but is slightly less secure.
        // A better approach would be to handle this logic in a Cloud Function.
    }
  }
}
